---
title: "DASC 623: Data Mining and Text Analysis"
subtitle: Dealing with Regular Expressions
author: "Jason Freels"
date: '`r format(Sys.Date(), "%d %b %Y")`'
output: 
  slidy_presentation:
    smart: no
    fig_caption: yes
graphics: yes
---

# Overview

<style>
div.plotly.html-widget {width: 800px;
                   height: 800px;
                   margin-left:auto;
                   margin-right:auto;}
</style>

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = !FALSE, 
                      fig.align = 'center',
                      message = F,
                      comment = ">>>",
                      warning = F,
                      collapse = T)

shiny::includeCSS("../resources/css/flatly-style.css")
shiny::includeCSS("../resources/css/r-title.css")
shiny::includeScript("../resources/js/jquery.min.js")
shiny::includeScript("../resources/js/jkf-scroll.js")

library(knitr)
library(reticulate)
library(rprojroot)
#reticulate::use_python("C:/Users/Aubur/Anaconda3/python.exe")
root = find_root(is_git_root)
```

- Many data analysis training sources de-emphasize dealing with strings 

    + The focus typically remains on numeric values
    + However, growth in data collection has led to in greater bits of information stored as strings  
    + As result, knowing how to process strings is now a prerequisite tool for data analysis
    
- This section covers the following foundational concepts for working with strings

    + Creating strings 
    + Joining strings
    + Formatting strings
    + Subsetting strings
    + Manipulating strings

- We'll demonstrate these methods in two ways

    + Using the `str` class that's part of the builtins module 
    + Using the numpy and `str` module that's part of pandas

- If you need help or want to learn more about these function see the code chunks below

    + Want to know what functions are available for `str` class objects created using builtins 
    + Want to know what functions are available for `str` class objects created using pandas 
    + Want to know what arguments these functions require
    + Want to see examples of how to use these functions

```{python, eval=F}
# review help for the str class from builtins
# this chunk is not executed since the resulting print outs are huge
help(__builtins__.str)

# or more concisely
help(str)
```

```{python}
# review help for the builtin function capitalize that's part of the str class 
help(str.capitalize)
```
```{python, eval=F}
# review help for the str class from pandas
# this is not executed since the resulting print out is huge
import pandas
help(pandas.Series.str)
```

```{python}
# review help for the pandas function capitalize that's part of the str class 
import pandas
help(pandas.Series.str.capitalize)
```

# Creating Strings using the `__builtins__.str` class

## Introduction

## Creating single-line strings

- The primary way to create a single-line string is to enclose some text with a quotation operator

    + Note that Python doesn't distinguish between single quotes `'` and double quotes `"` 
    + The string can then be assigned to a named object - similar to creating numeric objects

```{python}
a1 = "learning to create"    # create string a1 using double quotes
b1 = "character strings"     # create string b1 using double quotes
c1 = 'with Python is fun'    # create string c1 using single quotes

a1 ; b1 ; c1
```

- We can also create a string using the `str()` function that is part of the `builtins` module that is part of the basic Python installation 

    + There's no difference between creating a string using the quotation and using `str()`
    + Both methods create an `str` class object

```{python}
a2 = str("learning to create")    # create string a2 using str() and double quotes
b2 = str("character strings")     # create string b2 using str() and double quotes
c2 = str('with Python is fun')    # create string c2 using str() and single quotes

a2 ; b2 ; c2
```

## Creating multi-line strings

- Multi-line strings are created by enclosing the text with triple-quotation operator

    + Single quotation operators do not carry over to the next line
    + Triple-quotation operators can be composed of single-quotes or double-quotes
    + Multi-line quotes can make your code more readable
    + Recall that whitespace is important in Python and (as shown in the code chunks below) the output text maintains the formatting of the input text

```{python}
# create multi-line string abc using single quotes
abc = '''learning to create    
         character strings     
         with Python is fun'''

# newline `\n` escapes are maintained
abc

# Tabs and spacing are maintained
print(abc)
```

```{python}
# create multi-line string ABC using double quotes
ABC = """learning to create    
         character strings     
         with Python is fun"""

print(ABC)
```
- Note from the output of the code chunks above that we get a different result when we `print()` a string rather than when we simply evaluate it

## Creating strings by converting objects

- Strings may also be created by converting non-string objects 

```{python}
# Converting integer objects to strings
d = int(1)

str(d)

# Converting float objects to strings
import math
e = float(math.pi)

str(e)

# Converting boolean objects to strings
f = bool(True)

str(f)
```

- Note that the builtins library also include the `chr()` function

    + This takes integer values between 1 and `sys.maxunicode` as an argument
    + The function returns the Unicode representation the of the argument

```{python}
# Return the Unicode representation of int(1)
g = int(1)

chr(g)

# Return the Unicode representation of sys.maxunicode
sys.maxunicode

chr(sys.maxunicode)
```

## Subsetting strings

- It's important to understand how string objects are stored in Python

- Recall the multi-line string `ABC` that we created previously

```{python}
ABC
```

- If you've worked with other languages you may be inclined to think that `ABC` is stored as single element or a length-1 vector containing the all of the characters shown

- However - unlike other languages - Python does not natively support character type objects

- When we check on the length of `ABC` we might expect to see one (or perhaps three) but instead we get... 

```{python}
len(ABC)
```
- Furthermore, we can subset strings similar to how we would subset a list or an array - because this is how strings are stored!

```{python}
# Subset the 5th character in the string ABC
ABC[5]

# Cast ABC to a list object called ABC_list
ABC_list = list(ABC)

# Use join() to cast ABC_list back to a string
"".join(ABC_list)
```

# Working with strings using the `pandas.Series.str` module

## Introduction

- Recall, pandas is a Python library for manipulating one or more data `Series` objects

    + A `pandas.Series` object is a one-dimensional labeled array that contains data of any type (integer, string, float, bool, etc.)
    + Multiple `pandas.Series` objects can be combined to create a `pandas.DataFrame`

- When using the `pandas.Series.str` module we'll typically be working with an array of strings - not just one string

    + Creating string arrays
    + Adding a `pandas.Series.str` class object to an existing `pandas.DataFrame`
    + Extracting a `pandas.Series.str` class object from an existing `pandas.DataFrame`

- Note that the `pandas.Series.str` module contains functions <focus>for manipulating strings not creating them</focus>

- Therefore, we'll turn to `numpy` which does contain functions for creating string arrays   

```{python}
import pandas as pd
import numpy as np
```

## Creating string arrays from text

- Similar to what we showed for single strings in the last slide, we can create an array (or list) of strings by encapsulating a collection of strings in brackets  

```{python}
names = ["Moe", "Larry", "Curly"]

names
```

- We can then create a character array of arbitrary size can then be created by sampling `N` times from the object `names` with replacement

```{python}
# Define size of arbitrary array
N = 50

# Dray N samples from the names object
names_array = np.random.choice(names,N)

print(names_array)
type(names_array)
```

- Then we can create a `pandas.DataFrame` containing `names_array`

```{python}
names_df = pd.DataFrame(names_array, columns = ["names"])
names_df
```

- We could have also added `names_array` to an existing `pandas.DataFrame` 

    + This requires that the length of `names_array` is the same as the number of rows in the `pandas.DataFrame`

```{python}
# create an empty list
nums = []

# Append the value of i * 2 to the list
for i in range(N):
  nums.append(i * 2)

# Create a pandas.DataFrame containing nums
df = pd.DataFrame(nums, columns = ["nums"])

# add names_array to df as the column "names"
df["names"] = names_array

df
```

- We can also create a `pandas.DataFrame` containing strings directly using multi-line strings and `io.StringIO()`

```{python}
# create a multi-line string
ml_str = """Birthday;Name;Age;Over_40 
            10/2/2011;Music;42;True
            11/2/2011;Poetry;12;False
            12/2/2011;Theatre;50;True
            13/2/2011;Comedy;81;True
            """
ml_str

# import StringIO() from the io module 
from io import StringIO 
  
# use StringIO() to store ml_str  as a _io.StringIO class object  
StringData = StringIO(ml_str)
StringData
type(StringData)
  
# read the data using pandas.read_csv()
# each row in ml_str is defined as a row in df
# the argument sep defines what is stored in each column
df = pd.read_csv(StringData, sep =";") 

df
```
- Finally we can create an empty array and fill it with strings

    + In the code chunks below we create an empty character array and then fill it with `names_array`
    + There are several ways to do this - some faster and easier that others

```{python}
# create an empty numpy array with shape 50 rows X 1 column
char_array = np.empty((50,1))

# copy names_array over to char_array
char_array = names_array

# alternatively, we can also use numpy.chararray for this
char_array2 = np.chararray(shape=[50,1])

# copy names_array over to char_array2
char_array2 = names_array

# create a panda.DataFrame containing these arrays
char_df = pd.DataFrame({"array 1": char_array, "array 2": char_array2})

char_df
```

## Creating string arrays by converting non-string arrays

- For this set of examples let's import a data set stored as a `pandas.DataFrame`

    + The pandas library doesn't contain example data sets
    + Instead we can use the seaborn library which contains the well known iris data set

```{python}
import seaborn as sb

# load the iris data set as an object called iris
iris = sb.load_dataset('iris')

# view the first 5 rows of iris
iris.head()

# check the dimensions of the iris object
iris.shape

# check the iris object type 
type(iris)
```

- We can add a new column to the `iris` data set called `sepal_length_str` 

```{python}
iris["sepal_length_str"] = iris["sepal_length"].astype(str)

# check data types for sepal_length column
iris["sepal_length"].dtypes

# check data types for sepal_length_str column
iris["sepal_length"].dtypes

# check data types for all columns in iris
iris.dtypes
```

# Joining strings

The `str.join()` function provides a versatile means for creating and building strings

    + Takes one or more strings and concatenates (pastes) them to form one string separated by a spcified string
    + The separator string will often be an empty space, but could be anything

```{python}
# separate with an empty space
x = " ".join([a1, b1, c1])

print(x)

# separate with other symbols
x = "---".join([a1, b1, c1])

print(x)

# separate with chr symbols like the tab escape - \t
x = chr(9).join([a1, b1, c1])

print(x)

# separate with other chr symbols
x = chr(123).join([a1, b1, c1])

print(x)
```

# Formatting strings

## Overview

- When formatting strings you have at least two options 

    + Use the `%` operator for string substitution
    + Use the more modern `str.format()`

## Formatting strings using the `%` operator

- The `%` operator for strings is used string substitution

- String and Unicode objects have one unique built-in operation: the `%` operator (modulo).

This is also known as the string formatting or interpolation operator.

Given format % values (where format is a string or Unicode object), % conversion specifications in format are replaced with zero or more elements of values. The effect is similar to the using sprintf() in the C language.

If format is a Unicode object, or if any of the objects being converted using the %s conversion are Unicode objects, the result will also be a Unicode object.

```{python}
"\N{GREEK CAPITAL LETTER DELTA}"
import math

"The life of {pi} is {thing}".format(pi = math.pi, thing = "a good movie")

"The life of {pi:.4f} is {thing}".format(pi = math.pi, thing = "a good movie")
```

- For floating-point numbers, use `%f` for standard notation, and `%e` or `%E` for exponential notation:

```{python}
print(f"{math.pi:.4}")
repr(3)
f"{math.pi:.4}"

'%1.0f'%math.pi

print('%17.8E'%0.0665745511651039)

print(f"{math.pi:.0}")
```

    + `d` Signed integer decimal  
    + `i` Signed integer decimal
    + `o` Signed octal value
    + `u` Obsolete type - identical to `d`
    + `x` Signed hexadecimal - lowercase
    + `X` Signed hexadecimal - uppercase
    + `e` Floating point exponential format - lowercase
    + `E` Floating point exponential format - uppercase
    + `f` Floating point decimal format
    + `F` Floating point decimal format
    + `g` Floating point format - Uses lowercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise
    + `G` Floating point format - Uses uppercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise
    + `c` Single character - accepts integer or single character string
    + `r` String - converts any Python object using `repr()`
    + `s` String - converts any Python object using `str()`
    + `%` No argument is converted - results in a '%' character in the result


```{python}
sprintf("%f", pi)         # '%f' indicates 'fixed point' decimal notation
## [1] "3.141593"

sprintf("%.3f", pi)       # decimal notation with 3 decimal digits
## [1] "3.142"

sprintf("%1.0f", pi)      # 1 integer and 0 decimal digits
## [1] "3"

sprintf("%5.1f", pi)      # decimal notation with 5 total decimal digits and 
## [1] "  3.1"            # only 1 to the right of the decimal point

sprintf("%05.1f", pi)     # same as above but fill empty digits with zeros
## [1] "003.1"

sprintf("%+f", pi)        # print with sign (positive)
## [1] "+3.141593"

sprintf("% f", pi)        # prefix a space
## [1] " 3.141593"

sprintf("%e", pi)         # exponential decimal notation 'e'
## [1] "3.141593e+00"

sprintf("%E", pi)         # exponential decimal notation 'E'
## [1] "3.141593E+00"
```

```r
# paste together string a & b
paste(a, b)                      
## [1] "learning to create character strings"

# paste character and number strings (converts numbers to character class)
paste("The life of", pi)           
## [1] "The life of 3.14159265358979"

# paste multiple strings
paste("I", "love", "R")            
## [1] "I love R"

# paste multiple strings with a separating character
paste("I", "love", "R", sep = "-")  
## [1] "I-love-R"

# use paste0() to paste without spaces btwn characters
paste0("I", "love", "R")            
## [1] "IloveR"

# paste objects with different lengths
paste("R", 1:5, sep = " v1.")       
## [1] "R v1.1" "R v1.2" "R v1.3" "R v1.4" "R v1.5"
```

### Converting to Strings {#convert}

Test if strings are characters with `is.character()` and convert strings to character with `as.character()` or with `toString()`.


```{python}
a = "The life of"    
b = math.pi

isinstance(a, str)
type(a) == str
## [1] TRUE

isinstance(b,str)
## [1] FALSE

c = str(b)
isinstance(c, str)
## [1] TRUE

iris["sepal_width"].str.cat()
```

### Printing Strings {#print}

The common printing methods include:

- `print()`: generic printing
- `noquote()`: print with no quotes
- `cat()`: concatenate and print with no quotes
- `sprintf()`: a wrapper for the C function `sprintf`, that returns a character vector containing a formatted combination of text and variable values

The primary printing function in R is `print()`


```r
x <- "learning to print strings"    

# basic printing
print(x)                
## [1] "learning to print strings"

# print without quotes
print(x, quote = FALSE)  
## [1] learning to print strings
```

An alternative to printing a string without quotes is to use `noquote()`


```r
noquote(x)
## [1] learning to print strings
```

Another very useful function is `cat()` which allows us to concatenate objects and print them either on screen or to a file.  The output result is very similar to `noquote()`; however, `cat()` does not print the numeric line indicator.  As a result, `cat()` can be useful for printing nicely formatted responses to users.


```r
# basic printing (similar to noquote)
cat(x)                   
## learning to print strings

# combining character strings
cat(x, "in R")           
## learning to print strings in R

# basic printing of alphabet
cat(letters)             
## a b c d e f g h i j k l m n o p q r s t u v w x y z

# specify a seperator between the combined characters
cat(letters, sep = "-")  
## a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z

# collapse the space between the combine characters
cat(letters, sep = "")   
## abcdefghijklmnopqrstuvwxyz
```

You can also format the line width for printing long strings using the `fill` argument:


```r
x <- "Today I am learning how to print strings."
y <- "Tomorrow I plan to learn about textual analysis."
z <- "The day after I will take a break and drink a beer."

cat(x, y, z, fill = 0)
## Today I am learning how to print strings. Tomorrow I plan to learn about textual analysis. The day after I will take a break and drink a beer.

cat(x, y, z, fill = 5)
## Today I am learning how to print strings. 
## Tomorrow I plan to learn about textual analysis. 
## The day after I will take a break and drink a beer.
```

`sprintf()` is a useful printing function for precise control of the output. It is a wrapper for the C function `sprintf` and returns a character vector containing a formatted combination of text and variable values.

To substitute in a string or string variable, use `%s`:

If we specify fewer figures than we have in the integer portion of the float, we end up with an exponent representation instead:

```{python}
print(f"{x:.3}")
```


```r
x <- "print strings"

# substitute a single string/variable
sprintf("Learning to %s in R", x)    
## [1] "Learning to print strings in R"

# substitute multiple strings/variables
y <- "in R"
sprintf("Learning to %s %s", x, y)   
## [1] "Learning to print strings in R"
```

For integers, use `%d` or a variant:


```r
version <- 3

# substitute integer
sprintf("This is R version:%d", version)
## [1] "This is R version:3"

# print with leading spaces
sprintf("This is R version:%4d", version)   
## [1] "This is R version:   3"

# can also lead with zeros
sprintf("This is R version:%04d", version)   
## [1] "This is R version:0003"
```




### Counting string elements and characters {#count}

To count the number of elements in a string use `length()`:


```r
length("How many elements are in this string?")
## [1] 1

length(c("How", "many", "elements", "are", "in", "this", "string?"))
## [1] 7
```

To count the number of characters in a string use `nchar()`:


```r
nchar("How many characters are in this string?")
## [1] 39

nchar(c("How", "many", "characters", "are", "in", "this", "string?"))
## [1]  3  4 10  3  2  4  7
```

## String manipulation with base R {#string_manipulation_baseR}

Basic string manipulation typically inludes case conversion, simple character, abbreviating, substring replacement, adding/removing whitespace, and performing set operations to compare similarities and differences between two character vectors.  These operations can all be performed with base R functions; however, some operations (or at least their syntax) are greatly simplified with the `stringr` package.  This section illustrates base R string manipulation for [case conversion](#h1), [simple character replacement](#h2), [abbreviating](#h3), and [substring replacement](#h4). Many of the other fundamental string manipulation tasks will be covered in the [String manipulation with stringr](#string_manipulation_stringR) and [Set operatons for character strings](#set_operations) sections that follow.

### Case conversion {#h1}

To convert all upper case characters to lower case use `tolower()`:

```r
x <- "Learning To MANIPULATE strinGS in R"

tolower(x)
## [1] "learning to manipulate strings in r"
```

To convert all lower case characters to upper case use `toupper()`:


```r
toupper(x)
## [1] "LEARNING TO MANIPULATE STRINGS IN R"
```

### Simple Character Replacement {#h2}
To replace a character (or multiple characters) in a string you can use `chartr()`:


```r
# replace 'A' with 'a'
x <- "This is A string."
chartr(old = "A", new = "a", x)
## [1] "This is a string."

# multiple character replacements
# replace any 'd' with 't' and any 'z' with 'a'
y <- "Tomorrow I plzn do lezrn zbout dexduzl znzlysis."
chartr(old = "dz", new = "ta", y)
## [1] "Tomorrow I plan to learn about textual analysis."
```

Note that `chartr()` replaces every identified letter for replacement so the only time I use it is when I am certain that I want to change every possible occurrence of a letter.

### String Abbreviations {#h3}
To abbreviate strings you can use `abbreviate()`:


```r
streets <- c("Main", "Elm", "Riverbend", "Mario", "Frederick")

# default abbreviations
abbreviate(streets)
##      Main       Elm Riverbend     Mario Frederick 
##    "Main"     "Elm"    "Rvrb"    "Mari"    "Frdr"

# set minimum length of abbreviation
abbreviate(streets, minlength = 2)
##      Main       Elm Riverbend     Mario Frederick 
##      "Mn"      "El"      "Rv"      "Mr"      "Fr"
```

Note that if you are working with U.S. states, R already has a pre-built vector with state names (`state.name`).  Also, there is a pre-built vector of abbreviated state names (`state.abb`).

### Extract/Replace Substrings {#h4}
To extract or replace substrings in a character vector there are three primary base R functions to use: `substr()`, `substring()`, and `strsplit()`.  The purpose of `substr()` is to extract and replace substrings with specified starting and stopping characters:


```r
alphabet <- paste(LETTERS, collapse = "")

# extract 18th character in string
substr(alphabet, start = 18, stop = 18)
## [1] "R"

# extract 18-24th characters in string
substr(alphabet, start = 18, stop = 24)
## [1] "RSTUVWX"

# replace 1st-17th characters with `R`
substr(alphabet, start = 19, stop = 24) <- "RRRRRR"
alphabet
## [1] "ABCDEFGHIJKLMNOPQRRRRRRRYZ"
```

The purpose of `substring()` is to extract and replace substrings with only a specified starting point.  `substring()` also allows you to extract/replace in a recursive fashion:


```r
alphabet <- paste(LETTERS, collapse = "")

# extract 18th through last character
substring(alphabet, first = 18)
## [1] "RSTUVWXYZ"

# recursive extraction; specify start position only
substring(alphabet, first = 18:24)
## [1] "RSTUVWXYZ" "STUVWXYZ"  "TUVWXYZ"   "UVWXYZ"    "VWXYZ"     "WXYZ"     
## [7] "XYZ"

# recursive extraction; specify start and stop positions
substring(alphabet, first = 1:5, last = 3:7)
## [1] "ABC" "BCD" "CDE" "DEF" "EFG"
```

To split the elements of a character string use `strsplit()`:


```r
z <- "The day after I will take a break and drink a beer."
strsplit(z, split = " ")
## [[1]]
##  [1] "The"   "day"   "after" "I"     "will"  "take"  "a"     "break"
##  [9] "and"   "drink" "a"     "beer."

a <- "Alabama-Alaska-Arizona-Arkansas-California"
strsplit(a, split = "-")
## [[1]]
## [1] "Alabama"    "Alaska"     "Arizona"    "Arkansas"   "California"
```

Note that the output of `strsplit()` is a list.  To convert the output to a simple atomic vector simply wrap in `unlist()`:


```r
unlist(strsplit(a, split = "-"))
## [1] "Alabama"    "Alaska"     "Arizona"    "Arkansas"   "California"
```

## String manipulation with stringr {#string_manipulation_stringR}
The [`stringr`](http://cran.r-project.org/web/packages/stringr/index.html) package was developed by Hadley Wickham to act as simple wrappers that make R's string functions more consistent, simple, and easier to use.  To replicate the functions in this section you will need to install and load the `stringr` package:


```r
# install stringr package
install.packages("stringr")

# load package
library(stringr)
```

### Basic Operations 

There are three string functions that are closely related to their base R equivalents, but with a few enhancements:

* Concatenate with `str_c()`
* Number of characters with `str_length()`
* Substring with `str_sub()`


`str_c()` is equivalent to the [`paste()`](#create) functions: 


```r
# same as paste0()
str_c("Learning", "to", "use", "the", "stringr", "package")
## [1] "Learningtousethestringrpackage"

# same as paste()
str_c("Learning", "to", "use", "the", "stringr", "package", sep = " ")
## [1] "Learning to use the stringr package"

# allows recycling 
str_c(letters, " is for", "...")
##  [1] "a is for..." "b is for..." "c is for..." "d is for..." "e is for..."
##  [6] "f is for..." "g is for..." "h is for..." "i is for..." "j is for..."
## [11] "k is for..." "l is for..." "m is for..." "n is for..." "o is for..."
## [16] "p is for..." "q is for..." "r is for..." "s is for..." "t is for..."
## [21] "u is for..." "v is for..." "w is for..." "x is for..." "y is for..."
## [26] "z is for..."
```


`str_length()` is similiar to the [`nchar()`](#count) function; however, `str_length()` behaves more appropriately with missing ('NA') values: 


```r
# some text with NA
text = c("Learning", "to", NA, "use", "the", NA, "stringr", "package")

# compare `str_length()` with `nchar()`
nchar(text)
## [1] 8 2 2 3 3 2 7 7

str_length(text)
## [1]  8  2 NA  3  3 NA  7  7
```


`str_sub()` is similar to [`substr()`](#h4); however, it returns a zero length vector if any of its inputs are zero length, and otherwise expands each argument to match the longest. It also accepts negative positions, which are calculated from the left of the last character.


```r
x <- "Learning to use the stringr package"

# alternative indexing
str_sub(x, start = 1, end = 15)
## [1] "Learning to use"

str_sub(x, end = 15)
## [1] "Learning to use"

str_sub(x, start = 17)
## [1] "the stringr package"

str_sub(x, start = c(1, 17), end = c(15, 35))
## [1] "Learning to use"     "the stringr package"

# using negative indices for start/end points from end of string
str_sub(x, start = -1)
## [1] "e"

str_sub(x, start = -19)
## [1] "the stringr package"

str_sub(x, end = -21)
## [1] "Learning to use"

# Replacement
str_sub(x, end = 15) <- "I know how to use"
x
## [1] "I know how to use the stringr package"
```

### Duplicate Characters within a String 

A new functionality that stringr provides in which base R does not have a specific function for is character duplication:


```r
str_dup("beer", times = 3)
## [1] "beerbeerbeer"

str_dup("beer", times = 1:3)
## [1] "beer"         "beerbeer"     "beerbeerbeer"


# use with a vector of strings
states_i_luv <- state.name[c(6, 23, 34, 35)]
str_dup(states_i_luv, times = 2)
## [1] "ColoradoColorado"         "MinnesotaMinnesota"      
## [3] "North DakotaNorth Dakota" "OhioOhio"
```

### Remove Leading and Trailing Whitespace 

A common task of string processing is that of parsing text into individual words.  Often, this results in words having blank spaces (whitespaces) on either end of the word. The `str_trim()` can be used to remove these spaces:


```r
text <- c("Text ", "  with", " whitespace ", " on", "both ", " sides ")

# remove whitespaces on the left side
str_trim(text, side = "left")
## [1] "Text "       "with"        "whitespace " "on"          "both "      
## [6] "sides "

# remove whitespaces on the right side
str_trim(text, side = "right")
## [1] "Text"        "  with"      " whitespace" " on"         "both"       
## [6] " sides"

# remove whitespaces on both sides
str_trim(text, side = "both")
## [1] "Text"       "with"       "whitespace" "on"         "both"      
## [6] "sides"
```

### Pad a String with Whitespace 

To add whitespace, or to *pad* a string, use `str_pad()`.  You can also use `str_pad()` to pad a string with specified characters.


```r
str_pad("beer", width = 10, side = "left")
## [1] "      beer"

str_pad("beer", width = 10, side = "both")
## [1] "   beer   "

str_pad("beer", width = 10, side = "right", pad = "!")
## [1] "beer!!!!!!"
```


<br>

## Set operatons for character strings {#set_operations}
There are also base R functions that allows for assessing the set [union](#seth1), [intersection](#seth2), [difference](#seth3), [equality](#seth4), and [membership](#seth6) of two vectors. I also cover [sorting](#seth7) character strings. 

### Set Union {#seth1}
To obtain the elements of the union between two character vectors use `union()`:


```r
set_1 <- c("lagunitas", "bells", "dogfish", "summit", "odell")
set_2 <- c("sierra", "bells", "harpoon", "lagunitas", "founders")

union(set_1, set_2)
## [1] "lagunitas" "bells"     "dogfish"   "summit"    "odell"     "sierra"   
## [7] "harpoon"   "founders"
```

### Set Intersection {#seth2}
To obtain the common elements of two character vectors use `intersect()`:


```r
intersect(set_1, set_2)
## [1] "lagunitas" "bells"
```

### Identifying Different Elements {#seth3}
To obtain the non-common elements, or the difference, of two character vectors use `setdiff()`:


```r
# returns elements in set_1 not in set_2
setdiff(set_1, set_2)
## [1] "dogfish" "summit"  "odell"

# returns elements in set_2 not in set_1
setdiff(set_2, set_1)
## [1] "sierra"   "harpoon"  "founders"
```

### Testing for Element Equality {#seth4}
To test if two vectors contain the same elements regardless of order use `setequal()`:


```r
set_3 <- c("woody", "buzz", "rex")
set_4 <- c("woody", "andy", "buzz")
set_5 <- c("andy", "buzz", "woody")

setequal(set_3, set_4)
## [1] FALSE

setequal(set_4, set_5)
## [1] TRUE
```

### Testing for *Exact* Equality {#seth5}
To test if two character vectors are equal in content and order use `identical()`:


```r
set_6 <- c("woody", "andy", "buzz")
set_7 <- c("andy", "buzz", "woody")
set_8 <- c("woody", "andy", "buzz")

identical(set_6, set_7)
## [1] FALSE

identical(set_6, set_8)
## [1] TRUE
```

### Identifying if Elements are Contained in a String {#seth6}
To test if an element is contained within a character vector use `is.element()` or `%in%`:


```r
good <- "andy"
bad <- "sid"

is.element(good, set_8)
## [1] TRUE

good %in% set_8
## [1] TRUE

bad %in% set_8
## [1] FALSE
```

### Sorting a String {#seth7}
To sort a character vector use `sort()`:

```r
sort(set_8)
## [1] "andy"  "buzz"  "woody"

sort(set_8, decreasing = TRUE)
## [1] "woody" "buzz"  "andy"
```
